* Kyle's Configuration File
** meta-config
Stuff related to .emacs, .emacs.d, and generally making config work easier
*** .emacs.d
I like to have the emacs directory set relative to the .emacs file, and, correspondingly, this file:
#+BEGIN_SRC emacs-lisp
  (setq user-emacs-directory
        (file-truename (concat (getenv "HOME") "/.emacs.d/")))
#+END_SRC

*** Editing config
Work on the below once you've gone live, so you don't have to think
too hard about the alternative files right now
**** TODO Interactive function that takes me to configuration.org
This probably belongs in file map
**** TODO Interactive function that reloads config
Actually, an "eval-map" would probably be useful as well:
- Eval buffer
- Eval region
- Eval expression (honestly just use eshell)
- Eval .emacs
This could all easily exist in "SPC-e" (SPC-e-e for eshell kind of fits)
*** Custom packages
I maintain a number of custom packages (primarily for hammerspoon
integration) in a subfolder of this directory. I add it to the load
path here for future use with use-package:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name ".emacs_custom_packages" default-directory))
#+END_SRC

** Core Emacs Preferences
*** Scrolling/Buffer control
#+BEGIN_SRC emacs-lisp
  (setq-default scroll-conservatively 5)
#+END_SRC

*** Basic visual preferences
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (electric-pair-mode +1)
#+END_SRC

*** Movement preferences
Don't expect double-spaces after sentences. Effects "(" and ")" in
evil mode
#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)
#+END_SRC

*** Visual Bell
I actually like getting /some/ feedback when a command fails, but I
hate the audio beep and a full-screen flash is too much. This hack
allows me to flash just the mode line as the bell.
#+BEGIN_SRC emacs-lisp
(defun flash-mode-line ()
  (invert-face 'mode-line)
  (run-with-timer 0.05 nil #'invert-face 'mode-line))

(setq ring-bell-function #'flash-mode-line)
#+END_SRC
*** Backup files
Kill them So, it turns out backup files might be useful, and I might
want to consider configuring them someday. For now, auto-saves still
save me, and these files really feel like more trouble than they are
worth. See [[https://stackoverflow.com/questions/151945/how-do-i-control-how-emacs-makes-backup-files][here]] for details on how I might configure later though.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

*** Shell-command
Make sure you use .zshrc

#+BEGIN_SRC emacs-lisp
  (setq shell-command-switch "-ic")
#+END_SRC

** Emacs Functions
*** Window Sizing
'kjb/cycle-window-size' is a function meant to cycle the window split
size such that (size of window)/(frame size - size of window) toggles
between 1.0 (a 50-50 window split), 1.618 (Golden ratio, current
window larger), and 0.618 (Golden ratio, current window
smaller). Right now, I just have it set up for vertical splits because
this is my primary use-case. But a small bit of refactoring should
make this usable for horizontal splits as well.
#+BEGIN_SRC emacs-lisp
  (defvar cycle-window-count 0
    "Tracks which window size to cycle in kjb/cycle-window-size")

  (defun kjb/window-width-from-ratio (ratio)
    "Returns desired window width such that its size in columns
    divided by the remaining frame size equals `ratio':
  f = frame size
  w = window size <== solve for this
  r = ratio
  w / (f - w) = r
  w = (f - w)r
  w = fr - wr
  w + wr = fr
  w(1 + r) = fr
  w = fr / (1 + r)
  "
    (let
        ((frame-curr-width (frame-width))
         (window-curr-width (window-total-width)))
      (/ (* ratio frame-curr-width) (+ 1 ratio))))

  (defun kjb/window-delta-from-ratio (ratio)
    "Returns the desired delta for `enlarge-window-horizontally' so that
    window width is equal to the output from
    `kjb/window-width-from-ratio'. Returns an integer"
    (truncate (-
               (kjb/window-width-from-ratio ratio)
               (window-total-width))))

  ;; TODO handle when there is a single window to avoid a warning
  ;; message; non-urgent.
  (defun kjb/cycle-window-size ()
    "Toggle window size between half, more than half (golden ratio) and less than have (gr)"
    (interactive)
    (let*
        ((ratio-map
          '((0 . 1.618)
            (1 . 1.0)
            (2 . 0.618))))
      (progn
        (unless
            (and
             (eq this-command last-command)
             (<= cycle-window-count 2))
          (setq cycle-window-count 0))
        (enlarge-window-horizontally
         (kjb/window-delta-from-ratio
          (cdr (assoc cycle-window-count ratio-map))))
        (setq cycle-window-count (+ cycle-window-count 1)))))
#+END_SRC
*** Eshell
The advice `kjb/eshell-init-on-default-directory` ensures that eshell
opens into the directory that I'm currently located in. And as I now
write this out, I'm realizing that this could probably have just been
defined in a function, rather than advice... This would be more
extendable for other keybindings (for instance, SPACE-e-p could open
eshell in the projectile directory). Well, TODO I guess.

#+BEGIN_SRC emacs-lisp
  (defun kjb/run-in-eshell (cmd)
    (with-current-buffer "*eshell*"
      (end-of-buffer)
      (insert cmd)
      (eshell-send-input)
      (end-of-buffer)))

  (defun kjb/eshell-init-on-default-directory (orig-fun &rest args)
    (let
        ((destination_dir default-directory))
      (progn
        (apply orig-fun args)
        (cd destination_dir)
        (kjb/run-in-eshell ""))))

  (advice-add 'eshell :around #'kjb/eshell-init-on-default-directory)
#+END_SRC

*** Buffers
**** Sort by major mode
#+BEGIN_SRC emacs-lisp
  (defun kjb/buffers-with-major-mode (mode)
    "Returns a sequence of buffers filtered by the provide major mode."
    (seq-filter
     (lambda (buf)
       (with-current-buffer buf
         (eq (symbol-value 'major-mode) mode)))
     (buffer-list)))
#+END_SRC
*** Textual evaluation
"Insert" here uses a hack with evil-set-register and evil-paste-after.
I should probably extract that out to a common function at some point.
**** Insert Date
Inserts the current date in YYYY-MM-DD format. Stolen from ChatGPT.
Could be improved as it comes before the evil cursor, rather than
on/after it. Haven't figured out a good way to fix that for now.

#+BEGIN_SRC emacs-lisp
(defun kjb/insert-current-date ()
  "Inserts the current date in YYYY-MM-DD format at point."
  (interactive)
  (evil-set-register (max-char) (format-time-string "%Y-%m-%d"))
  (evil-paste-after 1 (max-char)))

#+END_SRC
**** Insert Math Result
Simple utility stolen from ChatGPT. It has a couple of problems that still need solving:
- It inserts behind the "normal-mode" evil cursor. This is a problem
  for the date function too. I need to figure out a generalized
  solution.
- I need a variation that reads in-line from the buffer somehow.

#+BEGIN_SRC emacs-lisp
(defun kjb/insert-math-result ()
  "Prompt for a simple math expression and insert the result at point."
  (interactive)
  (let ((expression (read-string "Expression: ")))
    (evil-set-register (max-char) (calc-eval expression))
    (evil-paste-after 1 (max-char))))
#+END_SRC
** Packages
*** Use-package
**** Initialize package with correct archives
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-archives `(("gnu" . "https://elpa.gnu.org/packages/")
                           ("melpa" . "https://melpa.org/packages/")
                           ("melpa-stable" . "https://stable.melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")))

  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))
#+END_SRC

**** Install use-package
Everything after this should use use-package for management
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

*** Theming
**** Doom
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :ensure t
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled
    (load-theme 'doom-one t))
#+END_SRC
**** Spacemacs (Inactive)
#+BEGIN_SRC emacs-lisp
  ;; (use-package spacemacs-theme
  ;;   :defer t
  ;;   :init
  ;;   (load-theme 'spacemacs-dark t))
#+END_SRC
**** Poet (Inactive)
Install poet, but just activate it when you are doing writing and it
makes sense for your eyes.
#+BEGIN_SRC emacs-lisp
  (use-package poet-theme
    :ensure t)
#+END_SRC

**** Fonts
***** all-the-icons
Using font-family-list to download ATI only once
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :config
    (unless (member "all-the-icons" (font-family-list))
      (all-the-icons-install-fonts t)))
#+END_SRC

*** Environment
Use `exec-path-from-shell` to copy the shell environment over into
Emacs when it starts in OS X. The MacOs application launcher doesn't
really handle the environment very well, so best to just copy shell
behavior
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :config
    (when (daemonp)
      (exec-path-from-shell-initialize)))
#+END_SRC
*** Company
**** Base-company
I can use the better 'after-init-hook when this loaded from my actual
.emacs file. While I'm running in portable mode, however,
`emacs-startup-hook is the best I'm going to be able to do
#+BEGIN_SRC emacs-lisp
  (use-package company
    :init
    (add-hook 'emacs-startup-hook #'global-company-mode)
    :config
    ;; Maintain case sensitivity for plaintext autocompletions.
    (setq company-dabbrev-downcase nil))
#+END_SRC

*** Evil
**** Basic package
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq-default evil-want-C-u-scroll t)
    :config
    (setq-default evil-shift-width 2) ;; lets be honest I prefer it this way
    (setq-default evil-scroll-count 10)
    (evil-set-initial-state 'Info-mode 'emacs) ;; best to use native emacs bindings in Info-mode
    (evil-mode 1))
#+END_SRC

**** evil-escape
#+BEGIN_SRC emacs-lisp
  (use-package evil-escape
    :config
    (evil-escape-mode))
#+END_SRC

**** evil-nerd-commenter
evil-nerd-commenter does a few things that comment-line and comment-dwim don't (or at least not without more work):
- It handles regions and lines interchangeably without issue
- It keeps the cursor on the line commented
- It doesn't comment the next line down in visual line mode
  #+BEGIN_SRC emacs-lisp
    (use-package evil-nerd-commenter)
  #+END_SRC

*** Counsel
Not using ivy anymore, but still like counsel for some search stuff
#+BEGIN_SRC emacs-lisp
  (use-package counsel)
#+END_SRC

*** SMOCE
Building up a SMOCE stack (or VMOCE, depending if I end up using
vertico instead), with the hope that this eventually replaces Ivy so
that I'm using built-in completion functions.
**** Vertico
Replaces selectrum (and ivy) as my completing-read UI.

Note that vertico-directory* functions seem to be set up in a distinct
emacs package in vertico. Thus the map binding may need to be
separated out into a `use-package vertico-directory` command at some
point in the future.

#+BEGIN_SRC emacs-lisp
  (use-package vertico
    :init
    (vertico-mode)
    :bind (:map vertico-map
                ("DEL" . vertico-directory-delete-char)))
#+END_SRC

Save history across sessions!
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :init
  (savehist-mode))
#+END_SRC
**** Marginalia
Haven't really done much beyond the base configuration here. Lots of
potential to customize when I have time. Works OOTB with Ivy!
#+BEGIN_SRC emacs-lisp
(use-package marginalia
  :bind (:map minibuffer-local-map
         ("s-a" . marginalia-cycle))

  :init

  ;; Must be in the :init section of use-package such that the mode
  ;; gets enabled right away. Note that this forces loading the
  ;; package.
  (marginalia-mode))
#+END_SRC
**** Orderless
Provides a "completion-style" that is really excellent for substring search.
#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :config
    (setq completion-styles (append '(orderless) completion-styles))
    (setq completion-category-overrides '((file (styles basic partial-completion)))))
#+END_SRC
**** Consult
This is the most high-level, integrated part of the stack. Provides
individual functions (like `consult-buffer`) which uses
completing-read in order to narrow the search, and supports live
preview (yay!). I'm not doing /any/ customization right now, just
playing with the functions raw, but there are already some things I
should consider iterating on:
- Live preview in a more controlled area - maybe a floating window?
- Better color coding if it's available to me.
#+BEGIN_SRC emacs-lisp
(use-package consult)
#+END_SRC
***** Buffers
Various buffer-related custom sources for consult.

*Vterm-mode buffers*
#+BEGIN_SRC emacs-lisp
(defvar kjb/consult--vterm-buffer-source
  `(:name  "Vterm Buffers"
	   :narrow ?v
	   :category buffer
	   :face consult-buffer
	   :action ,#'consult--buffer-action
	   :state ,#'consult--buffer-state
	   :items (closure
		      (t)
		      nil
		    (mapcar #'buffer-name
			    (kjb/buffers-with-major-mode 'vterm-mode)))))

(add-to-list 'consult-buffer-sources 'kjb/consult--vterm-buffer-source 'append)
#+END_SRC
**** Embark
Gives me contextual options for an active minibuffer selection or
thing at point. Currently, I have the key function `embark-act` bound
to shift-return. Works nicely! There's plenty of improvement available
here when we're ready:
- I'm mostly using the default embark bindings. They're pretty
  intuitive, and more than anything I just needed the "o" option. I'll
  customize these more as I learn to use the package
- I haven't bound `embark-dwim` because I don't really have a
  "default" action on a given target right now. This is something I
  expect to build out as I use embark more.
#+BEGIN_SRC emacs-lisp
(use-package embark
  :ensure t
  :bind
  (("S-<return>" . embark-act))         ;; pick some comfortable binding
  ;; TODO Make default DWIM targets after you've used embark for a while.
   ;; ("C-;" . embark-dwim)        ;; good alternative: M-.
   ;; ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'
  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
;; Recommended if also using consult, which I am.
(use-package embark-consult)
#+END_SRC

*** Avy
#+BEGIN_SRC emacs-lisp
  (use-package avy)
#+END_SRC

*** Ace
Link & Window I think
**** ace-window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :config
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
#+END_SRC

**** link-hint
ace-link is too complicated for me
#+BEGIN_SRC emacs-lisp
  (use-package link-hint)
#+END_SRC

*** Projectile
**** Base projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-mode +1))
#+END_SRC

**** Counsel projectile
So that I can use posframe here as well
#+BEGIN_SRC emacs-lisp
  ;; (use-package counsel-projectile
  ;;   :config
  ;;   (counsel-projectile-mode))
#+END_SRC

*** Neotree
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :init
    (setq neo-show-hidden-files t)
    ;; confirm to delete files, but not to create them
    (setq neo-confirm-create-file 'off-p)
    ;; Use all-the-icons if you're not on a terminal
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
    :config
    (defun neotree-projectile ()
      "Open NeoTree using the project root, focus on current buffer file.
  Borrowed from a config here: https://www.emacswiki.org/emacs/NeoTree.
  If neotree is open, closes it."
      (interactive)
      (if (neo-global--window-exists-p)
          (neotree-toggle)
        (let ((project-dir (projectile-project-root))
              (file-name (buffer-file-name)))
          (if project-dir
              (progn
                (neotree-dir project-dir)
                (neotree-find file-name))
            (message "Could not find git project root.")))))

    (add-hook 'neotree-mode-hook
              (lambda ()
                (define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter)
                (define-key evil-normal-state-local-map (kbd "TAB") 'neotree-stretch-toggle)
                (define-key evil-normal-state-local-map (kbd "gr") 'neotree-refresh)
                (define-key evil-normal-state-local-map (kbd "c") 'neotree-create-node)
                (define-key evil-normal-state-local-map (kbd "d") 'neotree-delete-node))))
#+END_SRC

*** Magit
**** Base Package
Still much to do here. Need to evil-ify it, for one
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :config
    (setq-default magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1))
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init 'magit))
#+END_SRC

**** Magit Customizations
I don't like the control-oriented confirm/cancel commands when working
with commit messages. Stealing the key-mapping from spacemacs here
because I don't use the comma in my day-to-day editing
#+BEGIN_SRC emacs-lisp
  (defvar with-editor-custom-map (make-sparse-keymap)
    "I want a with-editor leader that isn't ctrl-oriented")
  (define-key with-editor-custom-map (kbd "k") 'with-editor-cancel)
  (define-key with-editor-custom-map (kbd "c") 'with-editor-finish)

  (add-hook 'with-editor-mode-hook
            (lambda ()
              (define-key evil-motion-state-local-map (kbd ",") with-editor-custom-map)))
#+END_SRC

*** IEdit
#+BEGIN_SRC emacs-lisp
  (use-package iedit)
  (use-package evil-iedit-state)
#+END_SRC

*** Dired-hacks
**** dired-subtree
Enables a "tree-like" dired navigation
#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :config
    (setq-default dired-subtree-use-backgrounds nil))
#+END_SRC
**** Copy filename on rename
When renaming a file from dired, I often want the same file name but
in a different folder. Unfortunately, auto-completions for filenames
are based on the destination folder, which makes "moving" files with
complex names difficult. This is easier if I just copy the filename to
my killring any time I start a renaming operation. Then I can paste
the filename once I've moved to the folder I want.

#+BEGIN_SRC emacs-lisp
(advice-add 'dired-do-rename :before #'dired-copy-filename-as-kill)
#+END_SRC

*** Shell Support (Vterm)
Below I add vterm with some basic settings (requires evil).  Sets the
environment variable `DOGNAME` as a diagnostic and because I added it
when I first set this up, so I'm keeping it.

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :config
    (setq-default vterm-environment
                  '("DOGNAME=Nellie"))
    (evil-define-key 'normal vterm-mode-map (kbd "p") 'vterm-yank)
    (setq-default vterm-max-scrollback 100000))
#+END_SRC

Additionally, here is a dwim function (still very much a work in
progress) aimed at supporting my terminal-map (see keymappings)

#+BEGIN_SRC emacs-lisp
  (defun kjb/vterm-dwim (&optional hint)
    "Vterm dwim function. Takes a substring hint:

  = If the substring matches an existing vterm buffers, open it.

  - If the substring doesn't match an existing buffer, create it
    with that name

  - If the substring matches multiple vterm buffers, return them as
    a list of their buffer names."
    (interactive)
    (if (stringp hint)
        (let ((buffer-name
               (car-safe (member hint (mapcar #'buffer-name (buffer-list))))))
          ;; (message buffer-names)
          (message hint)
          (if (stringp buffer-name)
              (switch-to-buffer buffer-name)
            (vterm hint)))))


#+END_SRC

This is a function that simply starts vterm in the home directory. It
relies on the very handy `projectile` macro
`projectile-with-default-dir`, which does exactly what I need. Not
sure if it's in the public API, but projectile seems stable enough
that I'm ok with the dependency for this convenience for now.

#+BEGIN_SRC emacs-lisp
(defun kjb/vterm-home ()
  "Create a vterm in the home directory"
  (interactive)
  (projectile-with-default-dir (getenv "HOME")
    (vterm)))
#+END_SRC

*** TODO Language Support
Need to fill this out
- Major modes that need work:
  - Python
  - Typescript/Javascript
  - Java
  - C#
  - Ruby
**** DONE General
CLOSED: [2020-10-29 Thu 21:25]
#+BEGIN_SRC emacs-lisp
  (use-package flycheck)
  (use-package lsp-mode)
  (use-package lsp-ui)
#+END_SRC

**** DONE Lua
CLOSED: [2021-12-03 Fri 22:26]
#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :config
    (setq-default lua-indent-nested-block-content-align nil))
#+END_SRC
**** DONE rust
CLOSED: [2020-10-29 Thu 22:45]
#+BEGIN_SRC emacs-lisp
  (use-package rustic)
#+END_SRC

**** DONE Kotlin
CLOSED: [2021-01-19 Tue 20:33]
#+BEGIN_SRC emacs-lisp
  (use-package kotlin-mode)
#+END_SRC
**** TODO typescript/javascript
***** typescript-mode
#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode)
#+END_SRC

*Setting Up Tide*
#+BEGIN_SRC emacs-lisp
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    ;; company is an optional dependency. You have to
    ;; install it separately via package-install
    ;; `M-x package-install [ret] company`
    (company-mode +1))

  (use-package tide
    :config
    ;; aligns annotation to the right hand side
    (setq company-tooltip-align-annotations t)
    ;; formats the buffer before saving
    (add-hook 'before-save-hook 'tide-format-before-save)
    (add-hook 'typescript-mode-hook #'setup-tide-mode))


  (add-to-list 'auto-mode-alist '("\\.tsx\\'" . typescript-mode))
#+END_SRC

**** TODO java
**** TODO python
**** TODO ruby
**** TODO c#

**** DONE Web Files
CLOSED: [2021-04-03 Sat 19:38]
Using web-mode for html/mustache/php & variants.
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :config
    (setq-default web-mode-markup-indent-offset 2)
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode)))
#+END_SRC
**** Ledger
Ledger-mode provides syntax highlighting and auto-completion for
.journal-style accounting files. I've started moving family finances
slowly into ledger since the beginning of 2023, and this mode helps
enable that. While not a coding language like the other members of
this section, I feel it is still a "language" that belongs listed
here.

#+BEGIN_SRC emacs-lisp
(use-package ledger-mode
  :config
  (add-to-list 'auto-mode-alist '("\\.journal\\'" . ledger-mode))
  (org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages
	   '((ledger . t)))))

#+END_SRC

Additionally, this lets ledger blocks evaluate in org mode via org-babel
#+BEGIN_SRC emacs-lisp
(load-file ".emacs_custom_packages/ob-ledger.el")
#+END_SRC
*** Hammerspoon integration
With hammerspoon installed, I have a package, /hs-ivy/, which provides
some utilities so that I can use an ivy-like window selection. This is
promising, but further work is needed. Some things to consider:
- Better encapsulation of concerns on both the elisp and lua side
- A README in the hammerspoon folder, for better details
- Some auto window sizing, and other utilities.

*UPDATE* I have now added multiple packages for hamemrspoon and have
moved the `load-path` addition up to my meta-config. Long-term, this
stuff should probably live with Ivy, but I need to iterate on this a
bit (and also likely move from ivy to a different selection front-end)

#+BEGIN_SRC emacs-lisp
  ;; (use-package hs-ivy
  ;;   :ensure nil)
  (use-package hs-cr
    :ensure nil)
#+END_SRC
** TODO Code Editing
This is where you can set up all the lsp stuff
*** DONE General
CLOSED: [2021-01-19 Tue 20:33]
Here might be a good place to define the generic functions discussed
in the [[Language Map]] section. For now, see that defined submap for
generic keybindings.

Also here is where I should define some common preferences, such as
'lsp-ui-sideline-mode and disabling 'lsp-ui-doc-mode

"Return" sends cursor to the selected reference, kills the xref buffer:
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'motion xref--xref-buffer-mode-map (kbd "RET")
    (lambda ()
      (interactive)
      (xref-goto-xref 't)))
#+END_SRC

Make sure that  garbage collection and process reading are up to modern sizes
#+BEGIN_SRC emacs-lisp
  ;; 100mb
  (setq gc-cons-threshold 100000000)
  ;; 1mb
  (setq read-process-output-max (* 1024 1024))
#+END_SRC

*** DONE Rust
CLOSED: [2020-10-29 Thu 21:51]
Assumes rust-analyzer installed

#+BEGIN_SRC emacs-lisp
  (add-hook 'rust-mode-hook (
                             lambda ()
                             ;; Default is 'rust-analyzer because of rustic
                             (setq rust-indent-offset 2)
                             (eval (lsp))
                             (eval (lsp-ui-doc-enable nil))
                             (eval (lsp-ui-sideline-mode))
                             (setq lsp-ui-sideline-show-hover 't)
                             (setq lsp-ui-sideline-show-diagnostics 't)
                             )
            )
#+END_SRC

*** DONE Typescript/javascript
CLOSED: [2020-10-31 Sat 12:21]
Using https://github.com/sourcegraph/javascript-typescript-langserver for now, which is deprecated. Should switch to Theia
Actually it's not clear, this may be using theide. Need to research further
Tide might be the best answer actually: https://github.com/ananthakumaran/tide

After installing on a fresh machine it appears that you get walked
through the install. NPM is a dependency but that's all. Could try
tide at some point but lsp ui is so nice
**** typescript
#+BEGIN_SRC emacs-lisp
  (defun kjb/lsp-typescript-hook ()
    "Function to be added to `typescript-mode-hook' to configure `lsp-mode'"
    (lsp)
    (setq typescript-indent-level 2)
    (eval (lsp-ui-doc-enable t)))

  (add-hook 'typescript-mode-hook #'kjb/lsp-typescript-hook)
#+END_SRC

**** javascript
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'js-mode-hook
  ;;           (lambda ()
  ;;             (setq lsp-clients-typescript-server-args '("--stdio" "--tsserver-log-file=/Users/kybarton/ts-ls-log.txt"))
  ;;             (eval (lsp))
  ;;             (eval (lsp-ui-doc-enable nil))))
#+END_SRC

*** DONE Java
CLOSED: [2020-11-04 Wed 16:51]
*note* this is really only going to work on emacs 27+. You need native
json support to handle a java project of any significant size
#+BEGIN_SRC emacs-lisp
  (use-package lsp-java
    :config
    (setq lsp-enable-on-type-formatting nil)
    (setq lsp-java-format-on-type-enabled nil)
    (setq lsp-java-vmargs
          (list
           "-noverify"
           "-Xmx1G"
           "-XX:+UseG1GC"
           "-XX:+UseStringDeduplication"
           "-javaagent:/Users/kybarton/.lombok/lombok.jar"))) ;; tentatively the default location for lombok I guess

  (add-hook 'java-mode-hook
            (lambda ()
              (setq indent-tabs-mode nil)
              (eval (lsp))
              (eval (lsp-ui-doc-enable-nil))
              (setq lsp-ui-sideline-show-hover 't)))
#+END_SRC
**** TODO make the location of lombok more generic
*** C
Assumes that [[https://github.com/MaskRay/ccls][ccls]] is installed.
#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-hook (
                          lambda ()
                          (eval (lsp))
                          (eval (lsp-ui-doc-enable nil))
                          (eval (lsp-ui-sideline-mode))
                          (setq lsp-ui-sideline-show-hover 't)
                          (setq lsp-ui-sideline-show-diagnostics 't)))
#+END_SRC
*** TODO Python
*** TODO Ruby
*** TODO C#
** Org
*Note* org config here presumes the existence of `ispell`, which may
need to be installed on your OS. For Macs, `brew install ispell` seems
to work just fine.


#+BEGIN_SRC emacs-lisp
  (setq-default org-startup-indented 't)
  (setq-default org-pretty-entities 't)
  (setq-default org-log-done 'time)
  (setq-default org-startup-with-inline-images 't)
  (setq-default org-pretty-entities-include-sub-superscripts nil)
  ;; Make sure you can use `attr_html: :width height/width'
  ;; to prevent giant images from overhwelming the buffer.
  (setq-default org-image-actual-width nil)
  (setq-default org-return-follows-link t)
  (evil-define-key 'normal org-mode-map (kbd "t") 'org-todo)
  (evil-define-key 'normal org-mode-map (kbd "<tab>") 'org-cycle)
  ;; Don't evil-auto-indent in org mode pls
  (add-hook 'org-mode-hook (
                            lambda ()
                            (setq evil-auto-indent nil)))
  ;; Set visual line mode by default
  (add-hook 'org-mode-hook #'visual-line-mode)
  ;; Set flyspell (automatic inline spell-checking) mode on for org mode
  (add-hook 'org-mode-hook #'flyspell-mode)
  ;; Go save all org files when auto-save runs (helpful for agenda)
  (add-hook 'auto-save-hook #'org-save-all-org-buffers)
#+END_SRC

*** Style reference
*THISISBOLD* /this italics/ +this strikethrough+ _this underline_
*** Org-roam
Sets up the org-roam directory and some encryption preferences. Org
roam directory varies from computer-to-computer, but should always
point at the same Dropbox folder. In any event, the customization
could be more sophisticated here once I have a comp-specific config
solution set up.

#+BEGIN_SRC emacs-lisp
  (setq epa-file-encrypt-to '("kjbarton4@gmail.com"))
  ;; This should be ok as nil once `epa-file-encrypt-to' is filled, but
  ;; there is a bug. See https://superuser.com/a/1561209
  (setq epa-file-select-keys 1)
  (use-package org-roam
    :config
    (setq org-roam-directory
          (file-truename "/Users/kylebarton/Dropbox/Local/Org/org-roam"))
    ;; use gpg file extension to force encryption
    (setq org-roam-capture-templates
          '(("d" "default" plain "%?"
             :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org.gpg"
                                "#+title: ${title}")
             :unnarrowed t)))
    (org-roam-db-autosync-mode)

    ;; set up some dailies details
    (setq org-roam-dailies-directory "daily/")

    (setq org-roam-dailies-capture-templates
          '(("d" "default" entry
             "* %?"
             :target (file+head "%<%Y-%m-%d>.org.gpg"
                                "#+title: %<%Y-%m-%d>\n"))
            ("t" "timestamped note" entry
             "* %<%H>:%<%M>\n %?"
             :target (file+head+olp "%<%Y-%m-%d>.org.gpg"
                                    "#+title: %<%Y-%m-%d>\n"
                                    ("Minutes"))))))
#+END_SRC

Adds my custom `hs-org-capture` package for taking capture notes using
Hammerspoon shortcuts. Currently, relies on `org-roam` and `s`

TODO this falls beyond org-roam now; I'm using it for gtd/agenda stuff
too.

#+BEGIN_SRC emacs-lisp
  (use-package hs-org-capture
    :ensure nil)
#+END_SRC

Adds advice to `org-id-find` to first search the org-roam db with
`org-roam-id-find`. This improves efficiency when resolving remote org
references outside of the scope of org-roam -- in particular, this
allows me to reference custom IDs in tables in different org-roam
files, which enables my spreadsheeting system for family finances.

#+BEGIN_SRC emacs-lisp
  (defun kjb/org-id-find--around-advice (orig-fun &rest args)
    "Advice added to `org-id-find'. If the file location can be found
  with `org-roam-id-find', return that instead. Else, fall through
  to the traditional `org-id-find' function application"
    (let ((result (apply #'org-roam-id-find args)))
      (if (not result)
          (apply orig-fun args)
        result)))

  (advice-add 'org-id-find :around #'kjb/org-id-find--around-advice)
#+END_SRC

Finally, set org-id-track-globally to nil because behavior is weird
when it is enabled. Best to let org-roam handle this rather than org
directly right now.
#+BEGIN_SRC emacs-lisp
(setq org-id-track-globally nil)
#+END_SRC
**** Org-roam ui
Add org-roam-ui as a nicety so that you can visualize your madness.

#+BEGIN_SRC emacs-lisp
(use-package org-roam-ui
  :config
  (setq org-roam-ui-sync-theme t
	org-roam-ui-follow t
	org-roam-ui-update-on-save t
	org-roam-ui-open-on-start t))
#+END_SRC
**** Org-roam capture with links: an example
I played around with creating a capture template that included a link
to a known node before, but never got it to prime-time. I'm recording
as commented code here what I came up with.
#+BEGN_SRC emacs-lisp
;; (defun kjb/org-roam-id-from-title (title_arg)
;;   "Returns org roam ID for a given title. Checks aliases
;; secondarily to title."
;;   (let
;;       ((id_from_title (caar ;; takes first element of org-roam-db-query list
;; 		       (org-roam-db-query
;; 			[:SELECT id :FROM nodes :WHERE (= title $s1)]
;; 			title_arg
;; 			)))
;;        (id_from_alias (caar ;; takes first element of org-roam-db-query list
;; 		       (org-roam-db-query
;; 			[:SELECT node-id :FROM aliases :WHERE (= alias $s1)]
;; 			title_arg
;; 			))))
;;     (cond
;;      ((stringp id_from_title) id_from_title)
;;      ((stringp id_from_alias) id_from_alias))))

;; (defun kjb/org-roam-capture-gtd-project-id (node)
;;   "Private function to be called in the GTD Project capture
;; template. Returns the org roam id of GTD_PROJECT. The node
;; argument is supplied by org roam's template expansion system, but
;; it is unnecessary - the title is hard-coded."
;;   (kjb/org-roam-id-from-title "GTD_PROJECT"))


;; (setq org-roam-capture-templates
;;       '(("d" "default" plain "%?"
;; 	 :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org.gpg"
;; 			    "#+title: ${title}")
;; 	 :unnarrowed t)
;; 	("g" "GTD Project" plain
;; 	 "\n\n* [[id:${kjb/org-roam-capture-gtd-project-id}][GTD PROJECT]] \n* Summary \n %?"
;; 	 :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org.gpg"
;; 			    "#+title: ${title}"))))
#+END_SRC
*** Org-babel extensions
**** Shell
#+BEGIN_SRC emacs-lisp
(require 'ob-shell)
(org-babel-do-load-languages
   'org-babel-load-languages
   (append org-babel-load-languages
	   '((shell . t))))
#+END_SRC
**** GNU Plot
#+BEGIN_SRC emacs-lisp
(use-package gnuplot
  :ensure t)

(org-babel-do-load-languages
 'org-babel-load-languages
 (append org-babel-load-languages
	 '((gnuplot . t))))
#+END_SRC
**** SQL
#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 (append org-babel-load-languages
	 '((sql . t))))
#+END_SRC
** Markdown
I use emacs surprisingly little for markdown today (e.g. late 2023).
However, I'd like that to change. For now, we assume that `cmark-gfm`
is installed (`brew install cmark-gfm`), which provides
github-flavored markdown. I use that as my markdown command for
previewing.
#+BEGIN_SRC emacs-lisp
(setq markdown-command "cmark-gfm")
#+END_SRC
** Key Maps
*** Misc
Place for me to append key-mappings for various minor modes, which
don't necessarily have a good organization right now
**** ansi-term
Enable some pasting
#+BEGIN_SRC emacs-lisp
  (evil-define-key 'normal term-raw-map (kbd "p") 'term-paste)
#+END_SRC

*** Sub-maps
**** Help Functions
#+BEGIN_SRC emacs-lisp
  (defvar help-map (make-sparse-keymap)
    "Help & describe functions. General documentation")
  (define-key help-map (kbd "f") 'describe-function)
  (define-key help-map (kbd "v") 'describe-variable)
  (define-key help-map (kbd "k") 'describe-key)
#+END_SRC

**** Buffer Manipulation
#+BEGIN_SRC emacs-lisp
  (defvar buffer-map (make-sparse-keymap)
    "Buffer manipulation")
  (define-key buffer-map (kbd "D") 'kill-buffer-and-window)
  (define-key buffer-map (kbd "d") 'kill-current-buffer)
  (define-key buffer-map (kbd "b") 'consult-buffer)
  (define-key buffer-map (kbd "s")
              (lambda ()
                (interactive)
                (switch-to-buffer "*scratch*")))
  (define-key buffer-map (kbd "e")
              (lambda ()
                (interactive)
                (find-file (file-truename (concat (getenv "HOME") "/.emacs")))))
#+END_SRC

**** Window Manipulation
#+BEGIN_SRC emacs-lisp
  (defvar window-map (make-sparse-keymap)
    "Window manipulation")
  (define-key window-map (kbd "k") 'windmove-up)
  (define-key window-map (kbd "j") 'windmove-down)
  (define-key window-map (kbd "h") 'windmove-left)
  (define-key window-map (kbd "l") 'windmove-right)
  (define-key window-map (kbd "d") 'delete-window)
  (define-key window-map (kbd "D") 'ace-delete-window)
  (define-key window-map (kbd "w") 'ace-select-window)
  (define-key window-map (kbd "=") 'balance-windows)
  (define-key window-map (kbd "r") 'kjb/cycle-window-size)
#+END_SRC

**** Execution Map
#+BEGIN_SRC emacs-lisp
  (defvar execution-map (make-sparse-keymap)
    "Common executions")
  (define-key execution-map (kbd "e") 'eshell)
  (define-key execution-map (kbd "s") 'async-shell-command)
  (define-key execution-map (kbd "b") 'eval-buffer)
  (define-key execution-map (kbd "r") 'eval-region)
  (define-key execution-map (kbd "ps") 'projectile-run-async-shell-command-in-root)
  ;; Todo better place for this
  (define-key execution-map (kbd "d") 'kjb/insert-current-date)
  ;; Todo better place for this
  (define-key execution-map (kbd "m") 'kjb/insert-math-result)
#+END_SRC

**** File Manipulation
#+BEGIN_SRC emacs-lisp
  (defvar file-map (make-sparse-keymap)
    "File manipulation")
  (define-key file-map (kbd "s") 'save-buffer)
  (define-key file-map (kbd "f") 'find-file)
#+END_SRC

**** Dired Maps
***** Dired Activation/Control
#+BEGIN_SRC emacs-lisp
  (defvar dired-activate-map (make-sparse-keymap)
    "Activating dired in various locations")
  (define-key dired-activate-map (kbd ".") ;; open dired in current dir
              (lambda ()
                (interactive)
                (dired default-directory)))
  (define-key dired-activate-map (kbd "p") ;; open dired in project dir
              (lambda ()
                (interactive)
                (dired (projectile-project-root))))
  (define-key dired-activate-map (kbd "~") ;; open dired in project dir
              (lambda ()
                (interactive)
                (dired (getenv "HOME"))))
#+END_SRC

***** Dired Mode
Simple function to retreat out of a dired subdir
#+BEGIN_SRC emacs-lisp
  ;; kills subdir, puts cursor on its location in parent subdir
  (defun dired-retreat-from-subdir ()
    (interactive)
    (let ((parent-dir (dired-current-directory)))
      (dired-subtree-remove)
      (dired-goto-file parent-dir)))
#+END_SRC

dwim function so that I keep a dired buffer around as needed
#+BEGIN_SRC emacs-lisp
  (defun dired-find-file-dwim ()
    "Dired-find-file for actual files, and dired-find-alternate-file for
  directories. This way, I don't litter with a bunch of dired buffers,
  but I preserve one when I visit a file"
    (interactive)
    (let
        (
         (point-file (dired-get-file-for-visit))
         )
      (if
          (file-directory-p point-file)
          ;; I use dired functions instead of find-file
          ;; or find-alternate-file directly, because there is some
          ;; safety logic on dired's side that I don't want to recreate
          (dired-find-alternate-file)
        (dired-find-file))
      ))
#+END_SRC

I hate pretty much all dired defaults.
Maybe try to deactivate the default keymap somehow?
Overall keybindings look good here, but I should change this to match my mental model:
I'd like ONE dired buffer, filled with subdirs as needed. Quick command (SPC-d-d) sends
me back to that buffer. RET is mapped to opening a subdir for dirs, and opening a file (non-alternate)
for files. This could make dired my central "shell" command center if I can create a command to run
a shell command from 'dired-current-directory
#+BEGIN_SRC emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil) ;; why on earth is this disabled?
  (define-key dired-mode-map (kbd "RET") 'dired-find-file-dwim)
  ;; Go up a dir unless you're in a subdir, in which case collapse it
  (define-key dired-mode-map (kbd "u")
              (lambda ()
                (interactive)
                (if (equal (dired-current-directory) (expand-file-name default-directory))
                    ;; we're at the top level, go to ".."
                    (find-alternate-file "..")
                  ;; else, we're in a subdir, so close it
                  (dired-retreat-from-subdir))))
  (define-key dired-mode-map (kbd "n") 'evil-search-next)
  (define-key dired-mode-map (kbd "w") 'evil-forward-word-begin)
  (define-key dired-mode-map (kbd "v") 'evil-visual-char)
  (define-key dired-mode-map (kbd "x") 'dired-retreat-from-subdir)
  (define-key dired-mode-map (kbd "TAB") 'dired-subtree-insert)
  (define-key dired-mode-map (kbd "$") 'evil-end-of-line)
  (define-key dired-mode-map (kbd "g") 'revert-buffer)
#+END_SRC

**** Search
Note: Probably best to write this stuff in init.el, and move over afterwards
Intense filesystem/symbol searches here.
- Assumes ag installed
- Assumes fzf installed


*Note*: space-s-r for `replace-string` is probably a little
 basic. Text operations like this need some tuning.
#+BEGIN_SRC emacs-lisp
  (defvar search-map (make-sparse-keymap)
    "Search utilities")
  (define-key search-map (kbd "f") 'counsel-fzf)
  (define-key search-map (kbd "s") 'consult-ripgrep)
  (define-key search-map (kbd "e") 'evil-iedit-state/iedit-mode)
  (define-key search-map (kbd "r") 'replace-string)
#+END_SRC

**** Project Manipulation
Extending/customizing the projectile command map as needed here.Using
ag for now because it's a little more ubiquitous, but I can move over
to ripgrep if there's a compelling reason.
The below search function basically mimics counsel-projectile-ag, but
for some reason posframe isn't working with counsel-projectile-ag, but
does with counsel-ag.
*NOTE* The below mapping causes an error on reload because projectile
tries to map things behind "s". No effect on my workflow for now, but
there error will happen everytime I reload config
#+BEGIN_SRC emacs-lisp
  (define-key projectile-command-map (kbd "t") 'neotree-projectile)
  (define-key projectile-command-map (kbd "s")
              (lambda ()
                (interactive)
                (counsel-ag nil (projectile-project-root))))
#+END_SRC

**** Jump Map
Jumping around buffers
#+BEGIN_SRC emacs-lisp
  (defvar jump-map (make-sparse-keymap)
    "Keys for jumping around places, primarily with avy")

  (define-key jump-map (kbd "l") 'avy-goto-line)
#+END_SRC

**** Link Map
Opening & copying links
#+BEGIN_SRC emacs-lisp
  (defvar link-map (make-sparse-keymap)
    "Utilities for opening links")

  (define-key link-map (kbd "o") 'link-hint-open-link)
  (define-key link-map (kbd "c") 'link-hint-copy-link)
#+END_SRC

**** Language Map
Submap for lsp-related functions primarily, but should hold any
sementic "language"-related manipulations.

One nice improvement would
be to define generic functions, e.g. 'rename-impl, which would wrap
the dependency on lsp and define backup functions for situations where
lsp-mode is not active

*Update 2023-12-14*

This has become more of a generic content editing map for things which
have "language", in the broader sense:
- Lsp operations for code
- Filling paragraphs lines
- Manipulating org blocks
- spell-checking


I played around with having a distinct map for these non-lsp
operations: a "content" map, which lived on SPC-c. But Honestly SPC-l
feels better ergonomically. And this map can have a few different
meanings I feel.
#+BEGIN_SRC emacs-lisp
  (defvar language-map (make-sparse-keymap)
    "Mappings for various language/lsp bindings and manipulation")

  (define-key language-map (kbd "rr") 'lsp-rename)
  (define-key language-map (kbd "gr") 'lsp-find-references)
  (define-key language-map (kbd "aa") 'lsp-execute-code-action)
  (define-key language-map (kbd "fp") 'fill-paragraph)
  (define-key language-map (kbd "sp") 'ispell-word)
  (define-key language-map (kbd "[") #'org-do-promote)
  (define-key language-map (kbd "]") #'org-do-demote)
#+END_SRC
**** Knowledge Map
Submap for knowledge-base & personal organization
commands. Importantly, this submap powers commands for org-roam.

#+BEGIN_SRC emacs-lisp
  (defvar knowledge-map (make-sparse-keymap)
    "Mappings for various kb & org-roam bindings")

  (define-key knowledge-map (kbd "c") 'org-roam-capture)
  (define-key knowledge-map (kbd "f") 'org-roam-node-find)
  (define-key knowledge-map (kbd "i") 'org-roam-node-insert)
  (define-key knowledge-map (kbd "g") 'org-open-at-point)
  (define-key knowledge-map (kbd "dt") 'org-roam-dailies-goto-today)
  (define-key knowledge-map (kbd "dc") 'org-roam-dailies-capture-today)
  (define-key knowledge-map (kbd "dd") 'org-roam-dailies-goto-date)

#+END_SRC

**** Terminal Map
Submap for terminal-emulation commands, largely vterm. See details of
the dwim function in the vterm section.

#+BEGIN_SRC emacs-lisp
  (defvar terminal-map (make-sparse-keymap)
    "Mappings for various kb & org-roam bindings")

  (define-key terminal-map (kbd "1")
              (lambda ()
                (interactive)
                (kjb/vterm-dwim "VTERM_1")))
  (define-key terminal-map (kbd "2")
              (lambda ()
                (interactive)
                (kjb/vterm-dwim "VTERM_2")))
  (define-key terminal-map (kbd "3")
              (lambda ()
                (interactive)
                (kjb/vterm-dwim "VTERM_3")))
  (define-key terminal-map (kbd "4")
              (lambda ()
                (interactive)
                (kjb/vterm-dwim "VTERM_4")))
  (define-key terminal-map (kbd "t")
              (lambda ()
                (interactive)
                (consult-buffer '(kjb/consult--vterm-buffer-source))))
  (define-key terminal-map (kbd ".")
              (lambda ()
                (interactive)
                (vterm 'default-directory)))
  (define-key terminal-map (kbd "~") #'kjb/vterm-home)
#+END_SRC

*** Top-level-map
It needs to happen after submaps are defined
#+BEGIN_SRC emacs-lisp
  (defvar top-level-map (make-sparse-keymap)
    "Top level map to send functions to delegate maps")
  ;; direct commands (no need for a submap here yet
  (define-key top-level-map (kbd "SPC") 'execute-extended-command)
  (define-key top-level-map (kbd "cl") 'evilnc-comment-or-uncomment-lines)
  (define-key top-level-map (kbd "u") 'universal-argument)
  ;; To submaps
  (define-key top-level-map (kbd "e") execution-map)
  (define-key top-level-map (kbd "w") window-map)
  (define-key top-level-map (kbd "f") file-map)
  (define-key top-level-map (kbd "b") buffer-map)
  (define-key top-level-map (kbd "h") help-map)
  (define-key top-level-map (kbd "d") dired-activate-map)
  (define-key top-level-map (kbd "s") search-map)
  (define-key top-level-map (kbd "j") jump-map)
  (define-key top-level-map (kbd "x") link-map)
  (define-key top-level-map (kbd "l") language-map)
  (define-key top-level-map (kbd "k") knowledge-map)
  (define-key top-level-map (kbd "t") terminal-map)
  ;; Projectile has its own submap
  (define-key top-level-map (kbd "p") projectile-command-map)

  (evil-define-key 'motion 'global (kbd "SPC") top-level-map)
  ;; Info mode; another special one
  (evil-define-key 'motion Info-mode-map (kbd "SPC") top-level-map)
  ;; this is a problem from an organization standpoint. It should live in the dired space
  (define-key dired-mode-map (kbd "SPC") top-level-map)
  ;; same with magit
  (define-key magit-status-mode-map (kbd "SPC") top-level-map)
  ;; This jump-back command gels nicely with "gd"
  (evil-define-key 'motion 'global (kbd "gb") 'evil-jump-backward)
#+END_SRC

** Further work needed
*** TODO Organize this file a little better
**** DONE Load packages in a single section
CLOSED: [2020-10-27 Tue 22:39]
**** TODO Organize the remainder by domain
**** DONE Finally, key maps at the end
CLOSED: [2020-10-29 Thu 21:13]
*** DONE Org-mode
CLOSED: [2020-10-27 Tue 22:38]
Enable pretty mode, indents, etc
*** TODO Eshell/terminals
Get aliases set up, pretty prompt, maybe hook into dired/magit nicely.
**** TODO Eshell
Eshell is going to have to be a passion project for the most part. Lots of customizations here are possible:
***** TODO Make the prompt pretty
***** TODO Define an aliases file in a discoverable place
***** TODO ergonomic function to pipe output to scratch
***** TODO ergonomic function to pipe background function to a named buffer
e.g. ssh forwarding proxies
*** DONE Advanced Ivy
CLOSED: [2020-10-31 Sat 13:06]
Better search features/shortcuts, really just scratching the surface here I think
**** DONE Get +counsel-locate+ counsel-fzf up and running for intense filesystem file searches
CLOSED: [2020-10-28 Wed 21:55]
**** DONE Get counsel-ag up for both large filesystem symbol searches, and project scoping
CLOSED: [2020-10-28 Wed 21:55]
**** DONE Move to ivy-regex-ignore-orer for some searches (functions/variables/M-x, probably)
CLOSED: [2020-10-31 Sat 13:06]
*** DONE Multi-cursor editor
CLOSED: [2020-11-01 Sun 09:43]
IEdit perhaps? Look at alternatives
*** DONE Line jump/buffer nav
CLOSED: [2020-10-29 Thu 17:49]
avy maybe? Though it seems to struggle to perform with lsp
Mostly just jump-line, but could potentially do more char navigation with SPC-j-c
*** TODO TRAMP
Need to find an ergonomic way to cycle through known connections without typing out the whole ssh syntax
*** DONE Autocompletion
CLOSED: [2020-10-29 Thu 20:26]
Ideally, integrated well with ivy. Probably company mode
*** DONE Opening links
CLOSED: [2020-10-29 Thu 21:13]
*** DONE Magit
CLOSED: [2020-10-28 Wed 23:34]
Like, any of it.
*** DONE Window resizing
CLOSED: [2021-04-10 Sat 12:05]
Not sure how to do this
:APRIL2021:
Figured this out! Simply using some math and
window-total-size/frame-size. I've come a long way with elisp comfort.
:END:
*** DONE Upgrade to emacs 27
CLOSED: [2020-11-01 Sun 09:27]
Native JSON parsing support, among other things. Expect +a large+ some performance improvement
** Misc Notes:
*** Your first package? thedired.el
Make a singleton dired buffer, and various commands to navigate with it:
- thedired: function to start (or kill) a singleton dired buffer, with name thedired-buffer-name
  - could have an ARG that optionally specifies the starting directory
- thedired-from-here: function to navigate thedired-buffer-name to default-directory
- that might be... it? So simple
- idk my current dired setup is pretty smooth

*** Some things while watching emacs-from-scratch on dired:
*evil-collection-define-key* to define multiple keys for a keymap!
*dired-listing-switches* can have a --group-directories-first option which might be nice
You can "kill" lines in dired, which won't delete the files/folders, but just hide them
You can "mark" files, both under point, and by regex, and then take action on them
Dired for creating & extract archives! AAHHH
w-dired (dired-toggle-read-only?) allows you to edit names like it's a buffer, and then Z Z to "commit" those changes?
*** Journey to leave the terminal
- Make dired your "shell"
- Create ergonomic "async-shell-command" commands from within the dired buffer
**** Try to write a custom ivy function for async shell commands
Example/docs here https://oremacs.com/swiper/#example---counsel-locate
Also available on info-mode iirc
**** Pythong virtualenv's
https://github.com/jorgenschaefer/pyvenv seems to be a solution here
